---
import BaseLayout from '../components/BaseLayout.astro';
import { getEntry } from 'astro:content';
import { marked } from 'marked';
import '../styles/pages/home.css';

// Load content from markdown files
// Astro automatically processes content collections during build
// All content is rendered as static HTML
const aboutEntry = await getEntry('home', 'about');
const interestsEntry = await getEntry('home', 'interests');

const timeline = aboutEntry?.data.timeline || [];
const { Content: InterestsContent } = interestsEntry ? await interestsEntry.render() : { Content: null };

// Parse markdown in timeline text
// HTML is rendered at build time, not runtime
function parseMarkdown(text: string): string {
  return marked.parseInline(text) as string;
}
---

<BaseLayout 
  title="Khoa Ngo | Web Developer Portfolio" 
  description="Portfolio of Khoa Ngo (zoskisk) - Web Developer specializing in JavaScript, TypeScript, Node.js, Docker, and C#/.NET."
  currentPage="home"
>
  <section class="hero">
    <div class="hero__container">
      <div class="hero__content">
        <h1>Hi there, I'm Khoa.</h1>
        <p class="hero__tagline">Good things take time.</p>
        <ul class="skill-list" aria-label="Core skills">
          <li><a href="https://www.codingame.com/profile/83603140793bc15d729e1516e11dda281538186" class="pill">JS/TS</a></li>
          <li><a href="https://github.com/whoamilittl3fish/portfolio" class="pill">Docker</a></li>
          <li><a href="https://github.com/whoamilittl3fish" class="pill">Git</a></li>
          <li><a href="https://github.com/whoamilittl3fish/portfolio" class="pill">Node.js</a></li>
          <li><a href="https://github.com/whoamilittl3fish/QuanLyHopDong" class="pill">C#/.NET</a></li>
        </ul>
      </div>
      <button id="scroll-to-about" class="btn">
        â†“ my story
      </button>
    </div>
  </section>

  <section id="about" class="section">
    <div class="section__container">
      <h2 class="section__title">about</h2>
      <ul class="timeline" aria-label="Timeline of my story">
        {timeline.map((item: { year: string; text: string }) => (
          <li class="timeline__item">
            <span class="timeline__year">{item.year}</span>
            <p class="timeline__text" set:html={parseMarkdown(item.text)} />
          </li>
        ))}
      </ul>
    </div>
  </section>

  <section class="section">
    <div class="section__container">
      <h2 class="section__title">interests</h2>
      <div class="interests">
        {InterestsContent && <InterestsContent />}
      </div>
    </div>
  </section>

  <section id="contact" class="section">
    <div class="section__container">
      <p id="end-text" class="section__end text-muted"></p>
    </div>
  </section>
</BaseLayout>

<!-- Structured Data for SEO -->
<script type="application/ld+json" is:inline set:html={JSON.stringify({
  "@context": "https://schema.org",
  "@type": "Person",
  "name": "Khoa Ngo",
  "alternateName": "zoskisk",
  "url": "https://zoskisk.vercel.app",
  "jobTitle": "Web Developer",
  "description": "Web Developer specializing in JavaScript, TypeScript, Node.js, Docker, and C#/.NET",
  "knowsAbout": ["JavaScript", "TypeScript", "Node.js", "Docker", "C#", ".NET", "Git"],
  "sameAs": [
    "https://github.com/whoamilittl3fish",
    "https://www.codingame.com/profile/83603140793bc15d729e1516e11dda281538186"
  ]
}, null, 2)} />

<script>
  /**
   * Scroll to about section handler
   */
  const scrollButton = document.getElementById('scroll-to-about');
  const aboutSection = document.getElementById('about');
  
  if (scrollButton && aboutSection) {
    scrollButton.addEventListener('click', () => {
      const headerHeight = 60;
      const offset = aboutSection.getBoundingClientRect().top + window.pageYOffset - headerHeight;
      window.scrollTo({ top: offset, behavior: 'smooth' });
    });
  }
  
  /**
   * Typing effect for "endl... that's all for now."
   * Uses Intersection Observer for better performance
   */
  const TYPING_SPEED = 50;
  const FULL_TEXT = "endl... that's all for now.";
  
  const endText = document.getElementById('end-text');
  let hasTyped = false;
  let isTyping = false;
  
  function typeText() {
    if (hasTyped || !endText || isTyping) return;
    
    hasTyped = true;
    isTyping = true;
    let index = 0;
    endText.textContent = '';
    endText.classList.add('typing');
    
    function type() {
      if (!endText) return;
      if (index < FULL_TEXT.length) {
        endText.textContent = FULL_TEXT.substring(0, index + 1);
        index++;
        setTimeout(type, TYPING_SPEED);
      } else {
        isTyping = false;
        endText.classList.remove('typing');
      }
    }
    
    type();
  }
  
  // Use Intersection Observer for better performance
  if (endText && 'IntersectionObserver' in window) {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && !hasTyped) {
            typeText();
            observer.disconnect();
          }
        });
      },
      { rootMargin: '-100px 0px' }
    );
    
    observer.observe(endText);
  } else if (endText) {
    // Fallback for browsers without Intersection Observer
    function checkScroll() {
      if (hasTyped || !endText) return;
      
      const rect = endText.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      
      if (rect.top < windowHeight - 100) {
        typeText();
        window.removeEventListener('scroll', checkScroll);
      }
    }
    
    window.addEventListener('scroll', checkScroll, { passive: true });
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', checkScroll);
    } else {
      checkScroll();
    }
  }
</script>

<style>
  #end-text.typing::after {
    content: '|';
    animation: blink 1s infinite;
  }
  
  @keyframes blink {
    0%, 50% { opacity: 1; }
    51%, 100% { opacity: 0; }
  }
</style>
